{"version":3,"file":"codemirror-compose-change.umd.js","sources":["../src/Util.ts","../src/CoordinateChanges.ts","../src/ComposeChanges.ts","../src/codemirror-compose-change.ts"],"sourcesContent":["\nimport {FromTo} from \"./Types\";\n\n// Return negative / 0 / positive.  a < b iff posCmp(a, b) < 0 etc.\nexport function posCmp(a: CodeMirror.Position, b: CodeMirror.Position) {\n  return (a.line - b.line) || (a.ch - b.ch);\n}\n\n// True if inside, false if on edge.\nexport function posInsideRange(pos: CodeMirror.Position, range: FromTo) {\n  return posCmp(range.from, pos) < 0 && posCmp(pos, range.to) < 0;\n}\n\nexport function posInsideRangeInclusive(pos: CodeMirror.Position, range: FromTo) {\n  return posCmp(range.from, pos) <= 0 && posCmp(pos, range.to) <= 0;\n}\n\nexport function rangesEqual(range1: FromTo, range2: FromTo) {\n  return (posCmp(range1.from, range2.from) === 0) && (posCmp(range1.to, range2.to) === 0);\n}\n\nexport function randomString(length: number, chars=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\n  let result = \"\";\n  for (let i = length; i > 0; --i) result += chars[Math.floor(Math.random() * chars.length)];\n  return result;\n}\n\nexport function getCodeMirror(): CodeMirror.Doc {\n  let elem: any = document.querySelector(\".CodeMirror\");\n  if (!elem) throw new Error(\"Couldn't find CodeMirror elem\");\n\n  if (!elem[\"CodeMirror\"]) throw new Error(\"Couldn't find CodeMirror\");\n  return elem[\"CodeMirror\"];\n}\n\nexport function last<T>(array: T[]): T | undefined {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n","\nimport {FromTo} from \"./Types\";\nimport {last, posCmp} from \"./Util\";\n\nexport function convertPointToBeforeChange(point: CodeMirror.Position, change: CodeMirror.EditorChange): CodeMirror.Position | null {\n  let linesInserted = change.text.length - change.removed.length;\n  let line = point.line - linesInserted;\n\n  let postEditChangeRange = preEditToPostEditChangeRange(change);\n\n  if (point.line > postEditChangeRange.to.line) {\n    return {line, ch: point.ch};\n  } else if (point.line === postEditChangeRange.to.line) {\n    // Since we're undoing this change, we think of it as first removing change.text,\n    // then inserting change.removed. Hence,\n    let removed = change.text;\n    let inserted = change.removed;\n\n    return {\n      line,\n      ch: point.ch + adjustCh(change, removed, inserted)\n    };\n  } else if (posCmp(point, change.from) < 0) {\n    // Tried to convert point to before change but it was before change.from\n    return point;\n  } else {\n    // Tried to transform point that was inside of change\n    return null;\n  }\n}\n\nexport function convertPointToAfterChange(point: CodeMirror.Position, change: CodeMirror.EditorChange): CodeMirror.Position | null {\n  let linesInserted = change.text.length - change.removed.length;\n  let line = point.line + linesInserted;\n\n  if (point.line > change.to.line) {\n    return {line, ch: point.ch};\n  } else if (point.line === change.to.line) {\n    return {\n      line,\n      ch: point.ch + adjustCh(change, change.removed, change.text)\n    };\n  } else if (posCmp(point, change.from) < 0) {\n    // Tried to convert point to after change but it was before change.from\n    return point;\n  } else {\n    // Point was inside of change\n    return null;\n  }\n}\n\nfunction adjustCh(change: CodeMirror.EditorChange, removed: string[], inserted: string[]): number {\n  let ch = 0;\n\n  if (removed.length === 1 && inserted.length > 1) {\n    // Single remove multiple insert\n    ch -= last(removed).length;\n    ch += last(inserted).length;\n    ch -= change.from.ch;\n  } else if (removed.length === 1 && inserted.length === 1) {\n    // Single remove single insert\n    ch -= last(removed).length;\n    ch += last(inserted).length;\n  } else if (removed.length > 1 && inserted.length === 1) {\n    // Multiple remove single insert\n    // If multiple lines were removed, and only one was added, then ch gets bumped forward by change.from.ch\n    ch -= last(removed).length;\n    ch += last(inserted).length;\n    ch += change.from.ch;\n  } else if (removed.length > 1 && inserted.length > 1) {\n    // Multiple remove multiple insert\n    ch -= last(removed).length;\n    ch += last(inserted).length;\n  }\n\n  return ch;\n}\n\nexport function preEditToPostEditChangeRange(change: CodeMirror.EditorChange): FromTo {\n  let line = change.from.line + change.text.length - 1;\n\n  let ch: number;\n  if (change.text.length === 1) {\n    ch = change.from.ch + last(change.text).length;\n  } else {\n    ch = last(change.text).length;\n  }\n\n  let to = {line, ch};\n\n  return {\n    from: change.from,\n    to\n  };\n}\n\nexport function applyChange(cm: CodeMirror.Doc, change: CodeMirror.EditorChange) {\n  cm.replaceRange(change.text.join(\"\\n\"), change.from, change.to);\n}\n\nexport function reverseApplyChange(cm: CodeMirror.Doc, change: CodeMirror.EditorChange) {\n  let postEditChangeRange = preEditToPostEditChangeRange(change);\n\n  // Want (0, 2) to (1, 1)\n  console.log(\"postEditChangeRange in reverseApplyChange\", postEditChangeRange);\n\n  cm.replaceRange(change.removed.join(\"\\n\"), postEditChangeRange.from, postEditChangeRange.to);\n}\n","\n\nimport {convertPointToAfterChange, convertPointToBeforeChange, preEditToPostEditChangeRange} from \"./CoordinateChanges\";\nimport {FromTo} from \"./Types\";\nimport {last, posCmp, posInsideRangeInclusive, rangesEqual} from \"./Util\";\n\n/**\n * Given two changes, compose them to make another change that would have the exact same effect, if applied.\n * This is used to combine the changes produced by several OT operations into a single, more sensible change\n */\nexport function composeChanges(cm: CodeMirror.Doc, oldChange: CodeMirror.EditorChange, change: CodeMirror.EditorChange): CodeMirror.EditorChange {\n  // There are 3 coordinates systems, orig, middle, and final\n\n  // This is the range affected by the first change, in the \"middle\" coordinate system\n  let affectedMiddle: FromTo = preEditToPostEditChangeRange(oldChange);\n\n  // Does the new change's range (in the middle coordinate system) intersect with affectedMiddle?\n  if (rangesOverlap(affectedMiddle, change)) {\n    // There are 5 possible types of overlap\n\n    if (rangesEqual(affectedMiddle, change)) {\n      // The new change perfectly overwrites whatever the old change put there\n      return {\n        ...oldChange,\n        text: change.text\n      };\n    } else if (rangeContains(affectedMiddle, change)) {\n      // The second change is entirely within the text inserted by the first change\n\n      // The first part begins at oldChange.from and proceeds to some line and ch in oldChange.text\n      let [firstPart, unused] = splitTextByPositionDifference(oldChange.text, change.from, oldChange.from);\n\n      // The second part begins where change.text ends and proceeds through the remainder of oldChange.text\n      let [unused2, secondPart] = splitTextByPositionDifference(oldChange.text, change.to, oldChange.from);\n\n      let text = joinWithoutNewlines(joinWithoutNewlines(firstPart, change.text), secondPart);\n\n      return {\n        from: oldChange.from,\n        to: oldChange.to,\n        removed: oldChange.removed,\n        text,\n        origin: oldChange.origin\n      };\n    } else if (rangeContains(change, affectedMiddle)) {\n      // The second change overwrites all the text inserted by the first change\n\n      let to: CodeMirror.Position;\n      let removed: string[];\n      let text: string[];\n\n      let changeToInOrigCoords = convertPointToBeforeChange(change.to, oldChange);\n\n      if (posCmp(changeToInOrigCoords, oldChange.to) <= 0) {\n        // The oldChange removal went further into the document\n\n        to = oldChange.to;\n\n        let [initialRemoved, unused6] = splitTextByPositionDifference(change.removed, oldChange.from, change.from);\n        removed = joinWithoutNewlines(initialRemoved, oldChange.removed);\n\n        text = change.text;\n      } else {\n        // The change removal went further into the document\n\n        to = changeToInOrigCoords;\n\n        let [initialRemoved, unused6] = splitTextByPositionDifference(change.removed, oldChange.from, change.from);\n        let oldChangeToInMiddleCoords = convertPointToAfterChange(oldChange.to, oldChange);\n        let [unused9, finalRemoved] = splitTextByPositionDifference(change.removed, oldChangeToInMiddleCoords, change.from);\n        removed = joinWithoutNewlines(joinWithoutNewlines(initialRemoved, oldChange.removed), finalRemoved);\n\n        text = change.text;\n      }\n\n      return {\n        from: change.from,\n        to,\n        text,\n        removed,\n        origin: oldChange.origin\n      };\n    } else if (posCmp(change.from, affectedMiddle.from) < 0) {\n      // The second change overlaps on the left\n\n      let [changeRemoved, unused4] = splitTextByPositionDifference(change.removed, oldChange.from, change.from);\n      let removed = joinWithoutNewlines(changeRemoved, oldChange.removed);\n\n      let [unused5, remainingChange1Text] = splitTextByPositionDifference(oldChange.text, change.to, oldChange.from);\n      let text = joinWithoutNewlines(change.text, remainingChange1Text);\n\n      return {\n        from: change.from,\n        to: oldChange.to,\n        removed,\n        text,\n        origin: oldChange.origin\n      };\n    } else {\n      // The second change overlaps on the right\n\n      let to: CodeMirror.Position;\n      let removed: string[];\n\n      let changeToInOrigCoords = convertPointToBeforeChange(change.to, oldChange);\n\n      if (posCmp(changeToInOrigCoords, oldChange.to) <= 0) {\n        // The oldChange removal went further into the document\n        to = oldChange.to;\n        removed = oldChange.removed;\n      } else {\n        // The second change's removal goes further into the document;\n        to = changeToInOrigCoords;\n\n        let oldChangeToInMiddleCoords = convertPointToAfterChange(oldChange.to, oldChange);\n        let [unused3, extraRemoved] = splitTextByPositionDifference(change.removed, oldChangeToInMiddleCoords, change.from);\n        removed = joinWithoutNewlines(oldChange.removed, extraRemoved);\n      }\n\n      let [text, unused] = splitTextByPositionDifference(oldChange.text, change.from, oldChange.from);\n      text = joinWithoutNewlines(text, change.text);\n\n      return {\n        from: oldChange.from,\n        to,\n        text,\n        removed,\n        origin: oldChange.origin\n      };\n    }\n  } else {\n    // The new change's range is completely before or completely after the old change's range\n    if (rangeIsAfterInclusive(affectedMiddle, change)) {\n      // The new change precedes the old change\n\n      let middleStartPos = preEditToPostEditChangeRange(change).to;\n      let middleEndPos = convertPointToAfterChange(oldChange.from, change);\n      let middle = cm.getRange(middleStartPos, middleEndPos, \"\\n\");\n\n      return {\n        from: change.from,\n        to: oldChange.to,\n        removed: (change.removed.join(\"\\n\") + middle + oldChange.removed.join(\"\\n\")).split(\"\\n\"),\n        text: (change.text.join(\"\\n\") + middle + oldChange.text.join(\"\\n\")).split(\"\\n\"),\n        origin: oldChange.origin\n      };\n    } else {\n      // The old change precedes the new change\n      if (!rangeIsAfterInclusive(change, affectedMiddle)) console.error(\"RANGE WAS NOT AFTER\");\n\n      // Convert change.to to the \"orig\" coordinate system. This will be the \"to\" of the composed change\n      let finalTo = convertPointToBeforeChange(change.to, oldChange);\n      // Find the middle piece\n      let middleStartPos = affectedMiddle.to;\n      let middleEndPos = change.from;\n      let middle = cm.getRange(middleStartPos, middleEndPos, \"\\n\");\n\n      return {\n        from: oldChange.from,\n        to: finalTo,\n        text: (oldChange.text.join(\"\\n\") + middle + change.text.join(\"\\n\")).split(\"\\n\"),\n        removed: (oldChange.removed.join(\"\\n\") + middle + change.removed.join(\"\\n\")).split(\"\\n\"),\n        origin: oldChange.origin\n      };\n    }\n  }\n}\n\nfunction rangesOverlap(range1: FromTo, range2: FromTo): boolean {\n  if (rangeIsAfterInclusive(range2, range1)) return false;\n  if (rangeIsAfterInclusive(range1, range2)) return false;\n  return true;\n}\n\nfunction rangeIsAfterInclusive(range1: FromTo, range2: FromTo): boolean {\n  return posCmp(range2.to, range1.from) <= 0; // TODO: check this\n}\n\n// Return true if range2 is completely contained within range1\nfunction rangeContains(range1: FromTo, range2: FromTo): boolean {\n  return posInsideRangeInclusive(range2.from, range1) && posInsideRangeInclusive(range2.to, range1);\n}\n\nfunction joinWithoutNewlines(list1: string[], list2: string[]): string[] {\n  let ret = list1.slice(0, list1.length - 1);\n\n  ret.push(last(list1) + list2[0]);\n\n  ret.push(...list2.slice(1));\n\n  return ret;\n}\n\nfunction splitTextAt(text: string[], line: number, ch: number): [string[], string[]] {\n  let firstPart = [...text.slice(0, line),\n                   text[line].slice(0, ch)];\n\n  let secondPart = [text[line].slice(ch),\n                    ...text.slice(line + 1)];\n\n  return [firstPart, secondPart];\n}\n\nfunction splitTextByPositionDifference(text: string[], furtherPos: CodeMirror.Position, earlierPos: CodeMirror.Position): [string[], string[]] {\n  return splitTextAt(text,\n                     furtherPos.line - earlierPos.line,\n                     furtherPos.line === earlierPos.line ? furtherPos.ch - earlierPos.ch : furtherPos.ch);\n}\n","\nimport * as CoordinateChanges from \"./CoordinateChanges\";\nimport * as ComposeChanges from \"./ComposeChanges\";\n\nexport const composeChanges = ComposeChanges.composeChanges;\nexport const preEditToPostEditChangeRange = CoordinateChanges.preEditToPostEditChangeRange;\nexport const convertPointToAfterChange = CoordinateChanges.convertPointToAfterChange;\nexport const convertPointToBeforeChange = CoordinateChanges.convertPointToBeforeChange;\n"],"names":["composeChanges","ComposeChanges.composeChanges","preEditToPostEditChangeRange","CoordinateChanges.preEditToPostEditChangeRange","convertPointToAfterChange","CoordinateChanges.convertPointToAfterChange","convertPointToBeforeChange","CoordinateChanges.convertPointToBeforeChange"],"mappings":"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"}